var utils, defaultUtils;

module.exports = function setUtils(_utils, _defaultUtils) {

  utils = _utils;
  defaultUtils = _defaultUtils;

  for (var util in defaultUtils) {
    loadUtils[util] = defaultUtils[util];
  }

  return loadUtils;

}

module.exports.loadUtils = loadUtils;


function loadUtils(utilObj, load) {
  var path, desc, util
    , requested = {};

  // Juggle arguments
  if (utilObj instanceof Array) {
    load = utilObj;
    utilObj = loadUtils;
  } else {
    // Custom utilObj needs defaults:
    for (util in defaultUtils) {
      Object.defineProperty(utilObj, util, {
          value: defaultUtils[util]
        , enumerable: true
      });
    }
  }
  if (!load) {
    load = [];
  }

  // Which were requested?
  load.forEach(function(util) {
    if (!utils[util] && !defaultUtils[util]) {
      throw new utilErr( 'Utility "' + util + '" does not exist' );
    }
    requested[util] = true;
  });


  // If requested check deps and set a getter which require()'s it.
  // Else set a getter which throws an error
  for (util in utils) {
    desc = Object.getOwnPropertyDescriptor(utilObj, util);

    // Skip if previously required
    if ( desc && !desc.configurable ) continue;

    if ( requested[util] ){

        if ( !allResolve(utils[util]) ){
          throw new utilErr(
              'Utility "' + util
            + '" requested but is missing dependencies: '
            + utils[util].join(', ')
          );
        }

        Object.defineProperty(utilObj, util, {
            get: doRequire( util )
          , configurable: false
          , enumerable: true
        });

    } else {
      Object.defineProperty(utilObj, util, {
          get: wasntRequired(util)
        , configurable: true
        , enumerable: false
      });
    }

  } // end for(util in utils)

  return utilObj;

};



function doRequire(util) {
  return function () {
    return require('../lib/'+util);
  }
}



function wasntRequired(util) {
  return function () {
    var errMsg = 'Utility "' + util
               + '" was not passed to gulp-load-utils';
    if ( !allResolve(utils[util]) ) {
      errMsg += ' and is missing dependencies: "'
              + utils[util].join(', ')
              + '"';
    }
    throw new utilErr(errMsg);
  }
}



function allResolve(deps) {
  return deps.reduce(function(prev, dep) {
    try { return prev && !!require.resolve(dep); }
    catch (err) { return false; }
  }, true);
};



// Error with simplified stack trace
function utilErr(msg) {

  var orig = Error.prepareStackTrace;
  Error.prepareStackTrace = function(_, stack) { return stack; };
  var err = new Error;
  Error.captureStackTrace(err, utilErr);

  // Find CallSite that isn't native or this file
  for (var i=0; i<err.stack.length; i++) {
    if (!err.stack[i].isNative() && err.stack[i].getFileName() != __filename) {
      this.callSite = err.stack[i];
      break;
    }
  }

  Error.prepareStackTrace = orig;

  this.message = '[gulp-load-utils] ' + msg;
  this.fileName = this.callSite.getFileName();
  this.lineNumber = this.callSite.getLineNumber();
}
utilErr.prototype.toString = function () {
  return this.message + '\n\t' + this.callSite;
};